"""
Mermaid Exporter

Exports playbook diagrams to Mermaid flowchart format.
This format can be rendered in GitHub, GitLab, Notion, and other markdown viewers.
"""

from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime

from app.services.playbook_export_service import (
    playbook_export_service,
    TraversalResult,
    TraversedPlay,
    TraversedSection,
    TraversedTask,
    TraversedBlock,
    SectionType,
    BlockSectionType
)


@dataclass
class MermaidOptions:
    """Options for Mermaid export"""
    direction: str = "TB"  # TB, LR, BT, RL
    include_plays: bool = True
    include_sections: bool = True
    include_blocks: bool = True
    theme: str = "default"  # default, dark, forest, neutral


class MermaidExporter:
    """
    Exporter for Mermaid flowchart format.

    Generates flowchart diagrams that can be embedded in Markdown.
    Uses the playbook traversal service for consistent structure.
    """

    def export(
        self,
        plays: List[Dict[str, Any]],
        options: Optional[MermaidOptions] = None
    ) -> str:
        """
        Export plays to Mermaid flowchart format.

        Args:
            plays: List of play dictionaries
            options: Export options

        Returns:
            Mermaid flowchart string
        """
        if options is None:
            options = MermaidOptions()

        # Traverse the playbook structure
        traversal = playbook_export_service.traverse(plays)

        lines: List[str] = []

        # Header
        lines.append(f"flowchart {options.direction}")

        # Process each play
        for traversed_play in traversal.plays:
            play_lines = self._render_play(traversed_play, options)
            lines.extend(play_lines)

        return "\n".join(lines)

    def export_markdown(
        self,
        plays: List[Dict[str, Any]],
        playbook_name: str,
        options: Optional[MermaidOptions] = None
    ) -> str:
        """
        Export to Markdown with embedded Mermaid diagram.

        Args:
            plays: List of play dictionaries
            playbook_name: Name of the playbook
            options: Export options

        Returns:
            Markdown string with Mermaid code block
        """
        mermaid = self.export(plays, options)
        timestamp = datetime.utcnow().isoformat() + "Z"

        return f"""# {playbook_name or 'Playbook'} - Diagram

```mermaid
{mermaid}
```

---
*Generated by Automation Factory on {timestamp}*
"""

    def _render_play(
        self,
        traversed_play: TraversedPlay,
        options: MermaidOptions
    ) -> List[str]:
        """Render a play"""
        lines: List[str] = []
        play_id = f"play{traversed_play.index}"
        play = traversed_play.play
        play_name = play.get("name") or f"Play {traversed_play.index + 1}"

        if options.include_plays:
            lines.append(f'    subgraph {play_id}["{self._escape(play_name)}"]')
            lines.append(f"        direction {options.direction}")

        # Render each section
        for section in traversed_play.sections:
            if not section.items:
                continue

            section_lines = self._render_section(
                section, play_id, options
            )
            lines.extend(section_lines)

        # Render links between top-level items
        link_lines = self._render_links(traversed_play, options)
        lines.extend(link_lines)

        if options.include_plays:
            lines.append("    end")

        return lines

    def _render_section(
        self,
        section: TraversedSection,
        play_id: str,
        options: MermaidOptions
    ) -> List[str]:
        """Render a section"""
        lines: List[str] = []
        section_id = f"{play_id}_{section.name.value}"

        if options.include_sections:
            section_label = section.name.value.replace("_", " ")
            lines.append(f'        subgraph {section_id}["{section_label}"]')

        indent = "            " if options.include_sections else "        "

        # Render items
        for item in section.items:
            if isinstance(item, TraversedBlock):
                block_lines = self._render_block(item, indent, options)
                lines.extend(block_lines)
            elif isinstance(item, TraversedTask):
                task_line = self._render_task(item, indent)
                lines.append(task_line)

        if options.include_sections:
            lines.append("        end")

        return lines

    def _render_block(
        self,
        block: TraversedBlock,
        indent: str,
        options: MermaidOptions
    ) -> List[str]:
        """Render a block with its sections"""
        lines: List[str] = []
        block_module = block.block
        block_id = self._node_id(block_module["id"])
        block_label = playbook_export_service.get_module_label(block_module)

        if options.include_blocks:
            lines.append(f'{indent}subgraph {block_id}["{self._escape(block_label)}"]')

            inner_indent = indent + "    "
            task_indent = inner_indent + "    "

            # Render each block section
            block_sections = [
                ("normal", "block", block.normal_tasks),
                ("rescue", "rescue", block.rescue_tasks),
                ("always", "always", block.always_tasks)
            ]

            for section_key, section_label, tasks in block_sections:
                if tasks:
                    section_id = f"{block_id}_{section_key}"
                    lines.append(f'{inner_indent}subgraph {section_id}["{section_label}"]')

                    for task in tasks:
                        task_line = self._render_task(task, task_indent)
                        lines.append(task_line)

                    lines.append(f'{inner_indent}end')

            lines.append(f'{indent}end')
        else:
            # Render tasks flat if blocks disabled
            for task in block.normal_tasks + block.rescue_tasks + block.always_tasks:
                task_line = self._render_task(task, indent)
                lines.append(task_line)

        return lines

    def _render_task(self, task: TraversedTask, indent: str) -> str:
        """Render a task node"""
        module = task.module
        node_id = self._node_id(module["id"])
        label = playbook_export_service.get_module_label(module)
        return f'{indent}{node_id}["{self._escape(label)}"]'

    def _render_links(
        self,
        traversed_play: TraversedPlay,
        options: MermaidOptions
    ) -> List[str]:
        """Render links between nodes"""
        lines: List[str] = []
        play = traversed_play.play
        links = play.get("links", [])
        modules = play.get("modules", [])

        # Build module map
        module_map = {m["id"]: m for m in modules}

        # Track added links to avoid duplicates
        added_links = set()

        for link in links:
            from_module = module_map.get(link.get("from"))
            to_module = module_map.get(link.get("to"))

            if not from_module or not to_module:
                continue

            # Skip links from START nodes
            if from_module.get("isPlay"):
                continue
            if to_module.get("isPlay"):
                continue

            from_id = self._node_id(link["from"])
            to_id = self._node_id(link["to"])
            link_key = f"{from_id}->{to_id}"

            if link_key in added_links:
                continue
            added_links.add(link_key)

            link_type = link.get("type", "")

            if link_type == "rescue":
                lines.append(f"        {from_id} -.->|rescue| {to_id}")
            elif link_type == "always":
                lines.append(f"        {from_id} ==>|always| {to_id}")
            else:
                lines.append(f"        {from_id} --> {to_id}")

        return lines

    def _node_id(self, module_id: str) -> str:
        """Generate Mermaid-safe node ID"""
        return f"task_{module_id.replace('-', '_')}"

    def _escape(self, text: str) -> str:
        """Escape special characters for Mermaid labels"""
        return (
            text
            .replace('"', "'")
            .replace("[", "(")
            .replace("]", ")")
            .replace("{", "(")
            .replace("}", ")")
        )


# Singleton instance
mermaid_exporter = MermaidExporter()
